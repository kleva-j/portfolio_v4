import { OctagonAlert } from "lucide-react";

export const metadata = {
  title: "Introduction to Branded Types in Effect",
  description:
    "Discover how to leverage branded types in Effect to build type-safe APIs and prevent common errors.",
  summary:
    "Discover how to leverage branded types in Effect to build type-safe APIs and prevent common errors.",
  publishedAt: "2025-08-08",
  updatedAt: "2025-08-11",
  readTime: 5,
  image: "/images/learn-effect/image.png",
  alternates: {
    canonical: "/post/effects-branded-types-1",
  },
};

## Overview

Branded types in TypeScript provide a mechanism to create distinct types that are not interchangeable, even if they share the same underlying structure. In the Effect library, branded types enhance type safety by attaching unique tags to base types, ensuring robust API design and preventing runtime errors due to type misuse.

This article explores the problem of type alias limitations, demonstrates how Effect's branded types solve these issues, and provides practical examples of their implementation.

## The Problem with Type Aliases

Type aliases in TypeScript are structurally typed, meaning two aliases with the same underlying type are interchangeable. This can lead to runtime errors when distinct entities, such as `UserId` and `OrderId`, are mistakenly used in place of one another.

### Example: Type Alias Pitfall

```ts
type UserId = string;
type OrderId = string;

function getUser(id: UserId): string {
  return `User: ${id}`;
}

function getOrder(id: OrderId): string {
  return `Order: ${id}`;
}

const userId: UserId = "123";
const orderId: OrderId = "123";

console.log(getUser(userId)); // Output: "User: 123"
console.log(getUser(orderId)); // Bug! Output: "User: 123" (should be an Order)
```

**Issue**: Since both `UserId` and `OrderId` are aliases for `string`, TypeScript does not catch the error when an `OrderId` is passed to `getUser`. This structural typing can introduce subtle bugs that manifest at runtime.

## Solution: Branded Types with Effect

Effect's branded types address this issue by attaching a unique brand to a base type, making it distinct in TypeScript's type system. This ensures type safety at compile time without runtime overhead.

### Example: Using Branded Types

```ts
import { Brand } from "effect";

// Define branded types
type UserId = string & Brand.Brand<"UserId">;
type OrderId = string & Brand.Brand<"OrderId">;

// Create branded constructors
const UserId = Brand.nominal<UserId>();
const OrderId = Brand.nominal<OrderId>();

function getUser(id: UserId): string {
  return `User: ${id}`;
}

function getOrder(id: OrderId): string {
  return `Order: ${id}`;
}

// Create branded values
const userId = UserId("123"); // Branded as UserId
const orderId = OrderId("123"); // Branded as OrderId

console.log(getUser(userId)); // Output: "User: 123"
console.log(getOrder(orderId)); // Output: "Order: 123"

// Compile-time error
console.log(getUser(orderId)); // Error: Argument of type 'OrderId' is not assignable to parameter of type 'UserId'
```

### Benefits of Branded Types

- **Type Safety**: Ensures only correctly branded values are passed to functions, catching errors at compile time.
- **Uniqueness**: Brands create distinct types, preventing accidental interchangeability.
- **Zero Runtime Cost**: Branding is a compile-time construct, adding no performance overhead.

## Constructing Branded Types in Effect

Effect provides two primary methods for constructing branded types: <HighlightText>Brand.nominal</HighlightText> and <HighlightText>Brand.refined</HighlightText>.

### 1. Using <HighlightText>Brand.nominal</HighlightText>

The `Brand.nominal` function creates a branded type without runtime validation, ideal for scenarios where the input is already trusted.

```ts
import { Brand } from "effect";

type UserId = string & Brand.Brand<"UserId">;
const UserId = Brand.nominal<UserId>();

function getUser(id: UserId): string {
  return `User: ${id}`;
}

const userId = UserId("123");
console.log(getUser(userId)); // Output: "User: 123"

// Compile-time error
console.log(getUser("123")); // Error: Argument of type 'string' is not assignable to parameter of type 'UserId'
```

### 2. Using <HighlightText>Brand.refined</HighlightText>

The `Brand.refined` function allows for runtime validation through a predicate, ensuring the input meets specific criteria before branding.

```ts
import { Brand } from "effect";

type PositiveInt = number & Brand.Brand<"PositiveInt">;
const PositiveInt = Brand.refined<PositiveInt>(
  (n) => Number.isInteger(n) && n > 0,
  (n) => `Invalid PositiveInt: ${n} is not a positive integer`
);

function processId(id: PositiveInt): string {
  return `ID: ${id}`;
}

const validId = PositiveInt(42); // Success
console.log(processId(validId)); // Output: "ID: 42"

// Runtime error
const invalidId = PositiveInt(-1); // Throws: Invalid PositiveInt: -1 is not a positive integer
```

## Best Practices

- **Use Descriptive Brands**: Choose clear brand names (e.g., `UserId`, `OrderId`) to improve code readability.
- **Validate When Necessary**: Use `Brand.refined` for types requiring validation (e.g., positive numbers, specific formats).
- **Document Usage**: Clearly document branded types and their constructors to guide team members.
- **Combine with Domain Logic**: Integrate branded types into domain models to enforce business rules at the type level.

## Conclusion

Effect's branded types are a powerful tool for creating type-safe APIs in TypeScript. By distinguishing structurally identical types, they prevent runtime errors and enhance code maintainability. Whether using `Brand.nominal` for simple tagging or `Brand.refined` for validated types, branded types offer a robust solution for building reliable systems.

For further exploration, refer to the [Effect documentation](https://effect.website/docs) or experiment with branded types in your TypeScript projects.
